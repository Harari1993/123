import { Injectable, Optional } from '@angular/core';
import { CesiumService } from '../cesium/cesium.service';
var geodesy = require('geodesy');
var UTM = geodesy.Utm;
var LatLonEllipsoidal = geodesy.LatLonEllipsoidal;
export var CoordinateConverter = (function () {
    function CoordinateConverter(cesiumService) {
        this.cesiumService = cesiumService;
    }
    CoordinateConverter.prototype.screenToCartesian3 = function (screenPos) {
        if (!this.cesiumService) {
            throw new Error('ANGULAR2-CESIUM - Cesium service should be provided in order to do screen position calculations');
        }
        else {
            var camera = this.cesiumService.getViewer().camera;
            return camera.pickEllipsoid(screenPos);
        }
    };
    CoordinateConverter.prototype.screenToCartographic = function (screenPos, ellipsoid) {
        return this.cartesian3ToCartographic(this.screenToCartesian3(screenPos), ellipsoid);
    };
    CoordinateConverter.prototype.cartesian3ToCartographic = function (cartesian, ellipsoid) {
        return Cesium.Cartographic.fromCartesian(cartesian, ellipsoid);
    };
    CoordinateConverter.prototype.degreesToCartographic = function (longitude, latitude, height) {
        return Cesium.Cartographic.fromDegrees(longitude, latitude, height);
    };
    CoordinateConverter.prototype.radiansToCartographic = function (longitude, latitude, height) {
        return Cesium.Cartographic.fromRadians(longitude, latitude, height);
    };
    CoordinateConverter.prototype.degreesToUTM = function (longitude, latitude, height) {
        return new LatLonEllipsoidal(latitude, longitude, undefined, height).toUtm();
    };
    CoordinateConverter.prototype.UTMToDegrees = function (zone, hemisphere, easting, northing) {
        return this.geodesyToCesiumObject(new UTM(zone, hemisphere, easting, northing).toLatLonE());
    };
    CoordinateConverter.prototype.geodesyToCesiumObject = function (geodesyRadians) {
        return {
            longitude: geodesyRadians.lon,
            latitude: geodesyRadians.lat,
            height: geodesyRadians.height ? geodesyRadians.height : 0
        };
    };
    CoordinateConverter.decorators = [
        { type: Injectable },
    ];
    CoordinateConverter.ctorParameters = function () { return [
        { type: CesiumService, decorators: [{ type: Optional },] },
    ]; };
    return CoordinateConverter;
}());
//# sourceMappingURL=coordinate-converter.service.js.map